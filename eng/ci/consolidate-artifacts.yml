
schedules:
- cron: "30 2 * * *"
  displayName: Nightly Consolidation
  always: true
  branches:
    include:
      - main

trigger: none

# This pipeline is triggered by the completion of scheduled builds
# in the core-tools-inproc and core-tools-default pipelines
resources:
  repositories:
  - repository: 1es
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release
  - repository: eng
    type: git
    name: engineering
    ref: refs/tags/release
  pipelines:
    - pipeline: core-tools-host
      source: azure\azure-functions-core-tools\core-tools-host.official

    - pipeline: core-tools-inproc
      source: azure\azure-functions-core-tools\core-tools.official
      branch: in-proc  # in-proc branch of core-tools.official
      tags:
      - nightly-build
      trigger: 
        branches:
          include:
            - in-proc

    - pipeline: core-tools-default
      source: azure\azure-functions-core-tools\core-tools.official
      branch: main  # main branch of core-tools.official
      tags:
      - nightly-build
      trigger:
        branches:
          include:
            - main

variables:
- template: /ci/variables/cfs.yml@eng

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1es
  parameters:
    featureFlags:
      incrementalSDLBinaryAnalysis: true
      incrementalSDLSourceAnalysis: true
    pool:
      name: 1es-pool-azfunc
      image: 1es-windows-2022
      os: windows
    sdl:
      codeql:
         compiled:
           enabled: true
         runSourceLanguagesInSourceAnalysis: true
     
    stages:
    - stage: ConsolidateArticacts
      displayName: "Assemble Artifacts"
      jobs:
      - job: ProcessNuGetPackage
        displayName: "Process NuGet Package"
        templateContext:
          outputs:
            - output: pipelineArtifact
              displayName: Publish nuget package
              targetPath: $(Pipeline.Workspace)/staging
              artifact: drop-nuget-package
        steps:
        - checkout: none

        - download: core-tools-default
          artifact: drop
          displayName: "Download out-of-proc artifact"

        - powershell: |
            $currentRunName = $env:BUILD_REASON
            Write-Host "Current pipeline run name: $currentRunName"
            # Retrieve environment variables
            $defaultArtifactAlias = $env:DEFAULT_ARTIFACT_ALIAS
            $defaultArtifactName = $env:DEFAULT_ARTIFACT_NAME

            # Get the current working directory
            $currentDirectory = "$(Pipeline.Workspace)"

            # Construct the path using current directory, and environment variables
            $artifactPath = Join-Path -Path $currentDirectory -ChildPath "$defaultArtifactAlias\$defaultArtifactName"

            # Define the regex pattern to match the nupkg file (digit.digit.4digits)
            $regexPattern = "^Microsoft\.Azure\.Functions\.CoreTools\.\d+\.\d+\.\d{4}\.nupkg$"

            # Look for the first nupkg file that matches the pattern in the constructed path
            $fileToMove = Get-ChildItem -Path $artifactPath -Filter "*.nupkg" | Where-Object { $_.Name -match $regexPattern } | Select-Object -First 1

            # Check if a matching file was found
            if ($fileToMove -eq $null) {
                Write-Host "No .nupkg file matching the pattern was found in $artifactPath"
                exit 1
            }

            # Define the destination path in $(Pipeline.Workspace)/staging
            $nugetPackageDirectory = Join-Path -Path $(Pipeline.Workspace) -ChildPath "staging"

            # Create the staging directory if it doesn't exist
            if (-not (Test-Path $nugetPackageDirectory)) {
                New-Item -Path $nugetPackageDirectory -ItemType Directory
                Write-Host "Directory created at: $nugetPackageDirectory"
            }

            # Move the file to the staging directory
            Move-Item -Path $fileToMove.FullName -Destination $nugetPackageDirectory -Force

            Write-Host "File $($fileToMove.Name) moved to $nugetPackageDirectory"
          displayName: 'Process Microsoft.Azure.Functions.CoreTools NuGet Package'

      - job: AssembleArtifacts
        strategy:
          matrix:
            win-x64:
              artifactName: 'Azure.Functions.Cli.win-x64'
              artifactId: 'win-x64'
            win-x86:
              artifactName: 'Azure.Functions.Cli.win-x86'
              artifactId: 'win-x86'
            osx-x64:
              artifactName: 'Azure.Functions.Cli.osx-x64'
              artifactId: 'osx-x64'
            linux-x64:
              artifactName: 'Azure.Functions.Cli.linux-x64'
              artifactId: 'linux-x64'
            osx-arm64:
              artifactName: 'Azure.Functions.Cli.osx-arm64'
              artifactId: 'osx-arm64'
            win-arm64:
              artifactName: 'Azure.Functions.Cli.win-arm64'
              artifactId: 'win-arm64'
            min.win-x64:
              artifactName: 'Azure.Functions.Cli.min.win-x64'
              artifactId: 'min.win-x64'
            min.win-arm64:
              artifactName: 'Azure.Functions.Cli.min.win-arm64'
              artifactId: 'min.win-arm64'
            min.win-x86:
              artifactName: 'Azure.Functions.Cli.min.win-x86'
              artifactId: 'min.win-x86'
        displayName: "Assemble Artifacts"
        templateContext:
          outputs:
            - output: pipelineArtifact
              displayName: Publish assembled artifact $(System.JobPositionInPhase)
              targetPath: $(Build.ArtifactStagingDirectory)
              artifact: drop-$(artifactId)
            - output: pipelineArtifact
              displayName: Publish metadata.json
              targetPath: $(Pipeline.Workspace)/staging/metadata.json
              artifact: drop-metadata-json
              condition: and(succeeded(), eq(variables['artifactName'], 'Azure.Functions.Cli.min.win-x64')) 

        steps:
        - checkout: self

        - download: core-tools-host
          artifact: drop-coretools-host-linux-signed
          displayName: "Download core-tools-host linux"

        - download: core-tools-host
          artifact: drop-coretools-host-windows
          displayName: "Download core-tools-host windows"

        - download: core-tools-inproc
          artifact: drop-inproc6
          displayName: "Download inproc6 artifact"

        - download: core-tools-inproc
          artifact: drop-inproc8
          displayName: "Download inproc8 artifact"

        - download: core-tools-default
          artifact: drop
          displayName: "Download out-of-proc artifact"
                  
        - task: DotNetCoreCLI@2
          displayName: "Run ArtifactAssembler"
          inputs:
            command: run
            projects: "$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/Azure.Functions.ArtifactAssembler.csproj"
            arguments: ' -c release "$(artifactName)"'
            workingDirectory: '$(Pipeline.Workspace)'

        - task: PowerShell@2
          displayName: 'Generate metadata.json file'
          inputs:
            targetType: filePath
            filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/generateMetadataFile.ps1'
            arguments: '-StagingDirectory "$(Pipeline.Workspace)\staging"'
            workingDirectory: '$(Pipeline.Workspace)'
            condition: and(succeeded(), eq(variables['artifactName'], 'Azure.Functions.Cli.min.win-x64')) 

        - task: PowerShell@2
          displayName: 'Generate MSI files'
          inputs:
            targetType: filePath
            filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/generateMsiFiles.ps1'
            arguments: '-ArtifactsPath "$(Pipeline.Workspace)\staging\coretools-cli"'
            workingDirectory: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler'

        - task: EsrpCodeSigning@5
          displayName: 'ESRP CodeSigning'
          inputs:
            ConnectedServiceName: 'azfunc-internal-esrp'
            AppRegistrationClientId: 'a31bf239-3e15-498e-a335-f6ec0c9d9ccf'
            AppRegistrationTenantId: '72f988bf-86f1-41af-91ab-2d7cd011db47'
            AuthAKVName: 'kv-azfunc-esrp'
            AuthCertName: 'azfunc-internal-esrp-auth'
            AuthSignCertName: 'azfunc-internal-esrp-sign'
            FolderPath: '$(Pipeline.Workspace)\staging\coretools-cli'
            Pattern: '*.msi'
            signConfigType: inlineSignParams
            inlineOperation: |
              [
                          {
                            "KeyCode": "CP-230012",
                            "OperationCode": "SigntoolSign",
                            "Parameters": {
                              "OpusName": "Microsoft",
                              "OpusInfo": "http://www.microsoft.com",
                              "FileDigest": "/fd \"SHA256\"",
                              "PageHash": "/NPH",
                              "TimeStamp": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
                            },
                            "ToolName": "sign",
                            "ToolVersion": "1.0"
                          },
                          {
                            "KeyCode": "CP-230012",
                            "OperationCode": "SigntoolVerify",
                            "Parameters": {},
                            "ToolName": "sign",
                            "ToolVersion": "1.0"
                          }
              ]
            VerboseLogin: true
        - task: PowerShell@2
          displayName: 'Test Artifacts - Visual Studio'
          inputs:
            targetType: filePath
            filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/testVsArtifacts.ps1'
            arguments: '-StagingDirectory "$(Pipeline.Workspace)\staging\coretools-visualstudio"'
            workingDirectory: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler'
          condition: and(succeeded(), eq(variables['artifactName'], 'Azure.Functions.Cli.min.win-x64')) 

        - task: PowerShell@2
          displayName: 'Test Artifacts'
          inputs:
            targetType: filePath
            filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/testArtifacts.ps1'
            arguments: '-StagingDirectory "$(Pipeline.Workspace)\staging\coretools-cli"'
            workingDirectory: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler'
          condition: and(succeeded(), or(eq(variables['artifactName'], 'Azure.Functions.Cli.win-x64'), eq(variables['artifactName'], 'Azure.Functions.Cli.win-x86')))
        - task: DotNetCoreCLI@2
          displayName: 'Zip Artifacts'
          inputs:
            command: run
            projects: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/Azure.Functions.ArtifactAssembler.csproj'
            arguments: 'zip  -c release'
            workingDirectory: '$(Pipeline.Workspace)'
        - powershell: |
            $rootPath = "$(Pipeline.Workspace)\staging"
            $zipFiles = Get-ChildItem -Path $rootPath -Filter *.zip  -Recurse
            foreach ($file in $zipfiles) 
            {
                $sha = (Get-FileHash $file.FullName).Hash.ToLower()
                $shaFilePath = $file.FullName + ".sha2"
                Out-File -InputObject $sha -Encoding ascii -FilePath $shaFilePath -NoNewline
                Write-Host "Generated sha for $filePath at $shaFilePath"
            }
          displayName: 'Generate SHA files'

        - pwsh: |
            # Guardian files in TEMP add up and can cause the AntiMalware task to timeout.
            Get-ChildItem -Path $env:TEMP -Filter 'MpCmdRun.*' -Recurse -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force
          displayName: Cleanup Guardian related files in TEMP

        - task: CopyFiles@2
          displayName: 'Copy Files to Artifact Staging Directory'
          inputs:
            SourceFolder: '$(Pipeline.Workspace)/staging'
            Contents: 'coretools-*/**'
            TargetFolder: '$(Build.ArtifactStagingDirectory)'

        - powershell: |
            Write-Host "Artifacts are stored in:  D:\a\_work\1"
            Get-ChildItem -Path "D:\a\_work\1\a" -Recurse
          displayName: "List Artifact Paths"