parameters:
  - name: arch
    type: string
  - name: displayName
    type: string

jobs:
- job: AssembleArtifact${{ parameters.displayName }}
  displayName: "Assemble ${{ parameters.arch }}"
  templateContext:
    inputs:
      - input: pipelineArtifact
        pipeline: core-tools-host
        artifactName: drop-coretools-host-linux-signed
        targetPath: $(Pipeline.Workspace)\core-tools-host\drop-coretools-host-linux-signed
      - input: pipelineArtifact
        pipeline: core-tools-host
        artifactName: drop-coretools-host-windows
        targetPath: $(Pipeline.Workspace)\core-tools-host\drop-coretools-host-windows
      - input: pipelineArtifact
        pipeline: core-tools-inproc
        artifactName: drop-inproc6
        targetPath: $(Pipeline.Workspace)\core-tools-inproc\drop-inproc6
      - input: pipelineArtifact
        pipeline: core-tools-inproc
        artifactName: drop-inproc8
        targetPath: $(Pipeline.Workspace)\core-tools-inproc\drop-inproc8
      - input: pipelineArtifact
        pipeline: core-tools-default
        artifactName: drop
        targetPath: $(Pipeline.Workspace)\core-tools-default\drop
  
    outputParentDirectory: $(Build.ArtifactStagingDirectory)
    outputs:
      - output: pipelineArtifact
        displayName: Publish assembled artifact ${{ parameters.arch }}
        targetPath: $(Build.ArtifactStagingDirectory)/core-tools
        artifact: drop-${{ parameters.arch }}
      - output: pipelineArtifact
        displayName: Publish metadata.json
        targetPath: $(Build.ArtifactStagingDirectory)/metadata.json
        artifact: drop-metadata-json
        condition: and(succeeded(), eq('${{ parameters.arch }}', 'min.win-x64'))

  steps:
  - checkout: self

  - task: DotNetCoreCLI@2
    displayName: "Run ArtifactAssembler"
    inputs:
      command: run
      projects: "$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/Azure.Functions.ArtifactAssembler.csproj"
      arguments: '-c release -- "Azure.Functions.Cli.${{ parameters.arch }}"'
      workingDirectory: '$(Pipeline.Workspace)'

  - task: PowerShell@2
    displayName: 'Enhanced Directory Listing'
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "=================================================================="
        Write-Host "COMPREHENSIVE DIRECTORY LISTING" -ForegroundColor Green
        Write-Host "=================================================================="
        
        # Set paths
        $workspacePath = "$(Pipeline.Workspace)"
        $stagingPath = "$workspacePath/staging"
        $sourceDir = "$(Build.SourcesDirectory)"
        
        Write-Host "Workspace Path: $workspacePath" -ForegroundColor Cyan
        Write-Host "Staging Path: $stagingPath" -ForegroundColor Cyan
        Write-Host "Source Directory: $sourceDir" -ForegroundColor Cyan
        Write-Host ""
        
        # Function to format file size
        function Format-FileSize {
            param([long]$Size)
            
            if ($Size -ge 1GB) { return "{0:N2} GB" -f ($Size / 1GB) }
            elseif ($Size -ge 1MB) { return "{0:N2} MB" -f ($Size / 1MB) }
            elseif ($Size -ge 1KB) { return "{0:N2} KB" -f ($Size / 1KB) }
            else { return "$Size Bytes" }
        }
        
        # Function to check if a file exists with detailed output
        function Check-FileExists {
            param(
                [string]$FilePath,
                [string]$Description
            )
            
            if (Test-Path $FilePath) {
                Write-Host "‚úì $Description exists: $FilePath" -ForegroundColor Green
                
                # Get file info
                $fileInfo = Get-Item $FilePath
                $size = Format-FileSize $fileInfo.Length
                $lastModified = $fileInfo.LastWriteTime
                
                Write-Host "  Size: $size" -ForegroundColor Gray
                Write-Host "  Last Modified: $lastModified" -ForegroundColor Gray
                
                return $true
            } else {
                Write-Host "‚úó $Description NOT found: $FilePath" -ForegroundColor Red
                return $false
            }
        }
        
        # Function to recursively list directory contents with detailed info
        function Show-DetailedDirectory {
            param(
                [string]$Path,
                [string]$Indent = "",
                [int]$Level = 0,
                [int]$MaxLevel = 5,
                [switch]$ShowHidden = $false,
                [switch]$ShowAttributes = $false
            )
            
            if (-not (Test-Path $Path)) {
                Write-Host "${Indent}Directory does not exist: $Path" -ForegroundColor Red
                return
            }
            
            # Get items in the directory
            $getChildParams = @{
                Path = $Path
                ErrorAction = "SilentlyContinue"
            }
            
            if ($ShowHidden) {
                $getChildParams.Force = $true
            }
            
            $items = Get-ChildItem @getChildParams
            
            # Show directory stats
            $dirInfo = Get-Item $Path
            $dirName = Split-Path $Path -Leaf
            if ([string]::IsNullOrEmpty($dirName)) { $dirName = $Path }
            
            $fileCount = ($items | Where-Object { -not $_.PSIsContainer }).Count
            $dirCount = ($items | Where-Object { $_.PSIsContainer }).Count
            
            Write-Host "${Indent}üìÅ $dirName" -ForegroundColor Blue
            Write-Host "${Indent}  |-- Contains: $fileCount files, $dirCount directories" -ForegroundColor Gray
            
            if ($ShowAttributes) {
                Write-Host "${Indent}  |-- Created: $($dirInfo.CreationTime)" -ForegroundColor Gray
                Write-Host "${Indent}  |-- Modified: $($dirInfo.LastWriteTime)" -ForegroundColor Gray
                Write-Host "${Indent}  |-- Attributes: $($dirInfo.Attributes)" -ForegroundColor Gray
            }
            
            # Skip further processing if we've reached max depth
            if ($Level -ge $MaxLevel) {
                Write-Host "${Indent}  |-- [Max depth reached]" -ForegroundColor Yellow
                return
            }
            
            # Process directories first
            foreach ($dir in $items | Where-Object { $_.PSIsContainer } | Sort-Object Name) {
                Show-DetailedDirectory -Path $dir.FullName -Indent "${Indent}  |" -Level ($Level + 1) -MaxLevel $MaxLevel -ShowHidden:$ShowHidden -ShowAttributes:$ShowAttributes
            }
            
            # Then process files
            $fileGroups = @{}
            
            foreach ($file in $items | Where-Object { -not $_.PSIsContainer } | Sort-Object Name) {
                $ext = $file.Extension.ToLower()
                if (-not $fileGroups.ContainsKey($ext)) {
                    $fileGroups[$ext] = @()
                }
                $fileGroups[$ext] += $file
            }
            
            # Process files by extension groups
            foreach ($ext in $fileGroups.Keys | Sort-Object) {
                $files = $fileGroups[$ext]
                Write-Host "${Indent}  |-- $($files.Count) files with extension: $ext" -ForegroundColor Cyan
                
                foreach ($file in $files) {
                    $size = Format-FileSize $file.Length
                    
                    # Determine icon and color based on extension
                    $icon = "üìÑ"
                    $color = "White"
                    $fileType = ""
                    
                    switch -Regex ($ext) {
                        '\.exe$|\.com$|\.bat$|\.cmd$|\.ps1$' { 
                            $icon = "üöÄ"; $color = "Red"; $fileType = "[Executable] " 
                        }
                        '\.dll$|\.so$|\.dylib$' { 
                            $icon = "üì¶"; $color = "Green"; $fileType = "[Library] " 
                        }
                        '\.zip$|\.rar$|\.7z$|\.tar$|\.gz$' { 
                            $icon = "üóúÔ∏è"; $color = "Magenta"; $fileType = "[Archive] " 
                        }
                        '\.msi$|\.msix$|\.appx$' { 
                            $icon = "üì•"; $color = "Red"; $fileType = "[Installer] " 
                        }
                        '\.wxs$|\.wixobj$|\.wixpdb$' { 
                            $icon = "üìã"; $color = "Yellow"; $fileType = "[WiX] " 
                        }
                        '\.json$|\.xml$|\.config$' { 
                            $icon = "‚öôÔ∏è"; $color = "Yellow"; $fileType = "[Config] " 
                        }
                        '\.cs$|\.fs$|\.vb$|\.cpp$|\.h$' { 
                            $icon = "üíª"; $color = "Blue"; $fileType = "[Source] " 
                        }
                        '\.txt$|\.log$|\.md$' { 
                            $icon = "üìÉ"; $color = "White"; $fileType = "[Text] " 
                        }
                        '\.sha1$|\.sha2$|\.sha256$' { 
                            $icon = "üîê"; $color = "Cyan"; $fileType = "[Hash] " 
                        }
                    }
                    
                    Write-Host "${Indent}  |  $icon $fileType$($file.Name) ($size)" -ForegroundColor $color
                    
                    if ($ShowAttributes) {
                        Write-Host "${Indent}  |     Modified: $($file.LastWriteTime)" -ForegroundColor Gray
                        if ($ext -eq ".dll" -or $ext -eq ".exe") {
                            # Show version info for binaries
                            try {
                                $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($file.FullName)
                                if ($versionInfo.FileVersion) {
                                    Write-Host "${Indent}  |     Version: $($versionInfo.FileVersion)" -ForegroundColor Gray
                                }
                            } catch {
                                # Ignore version info errors
                            }
                        }
                    }
                }
            }
        }
        
        # Start measurement
        $startTime = Get-Date
        
        # Check if staging directory exists
        if (Test-Path $stagingPath) {
            Write-Host "STAGING DIRECTORY STRUCTURE" -ForegroundColor Magenta
            Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
            
            # Get subdirectories of staging
            $stagingSubdirs = Get-ChildItem -Path $stagingPath -Directory
            
            foreach ($subdir in $stagingSubdirs) {
                $totalSize = (Get-ChildItem -Path $subdir.FullName -Recurse -File -ErrorAction SilentlyContinue | 
                            Measure-Object -Property Length -Sum).Sum
                $formattedSize = Format-FileSize $totalSize
                
                Write-Host "Analyzing $($subdir.Name) ($formattedSize)..." -ForegroundColor Yellow
                Show-DetailedDirectory -Path $subdir.FullName -MaxLevel 3 -ShowAttributes
                Write-Host ""
            }
            
            # Special handling for metadata.json if it exists
            $metadataPath = "$stagingPath/metadata.json"
            if (Test-Path $metadataPath) {
                Write-Host "METADATA.JSON FOUND" -ForegroundColor Green
                Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
                $metadataFile = Get-Item $metadataPath
                $size = Format-FileSize $metadataFile.Length
                Write-Host "Size: $size" -ForegroundColor Gray
                Write-Host "Last Modified: $($metadataFile.LastWriteTime)" -ForegroundColor Gray
                
                # Try to display JSON content
                try {
                    $jsonContent = Get-Content $metadataPath -Raw | ConvertFrom-Json
                    Write-Host "Content preview:" -ForegroundColor Yellow
                    $jsonContent | Format-List | Out-String | Write-Host -ForegroundColor Gray
                } catch {
                    Write-Host "Couldn't parse metadata.json as valid JSON: $_" -ForegroundColor Red
                }
                Write-Host ""
            }
            
            # Check for MSI files
            $msiFiles = Get-ChildItem -Path $stagingPath -Recurse -Filter "*.msi"
            if ($msiFiles.Count -gt 0) {
                Write-Host "MSI FILES FOUND: $($msiFiles.Count)" -ForegroundColor Green
                Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
                foreach ($msi in $msiFiles) {
                    $size = Format-FileSize $msi.Length
                    Write-Host "üì• $($msi.Name) ($size)" -ForegroundColor Red
                    Write-Host "  Path: $($msi.FullName)" -ForegroundColor Gray
                    Write-Host "  Last Modified: $($msi.LastWriteTime)" -ForegroundColor Gray
                    Write-Host ""
                }
            } else {
                Write-Host "NO MSI FILES FOUND" -ForegroundColor Yellow
                Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
                Write-Host ""
            }
        } else {
            Write-Host "‚ùå STAGING DIRECTORY NOT FOUND: $stagingPath" -ForegroundColor Red
            Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
            
            # List workspace root to help diagnose
            Write-Host "WORKSPACE DIRECTORY CONTENT:" -ForegroundColor Yellow
            if (Test-Path $workspacePath) {
                Get-ChildItem -Path $workspacePath | ForEach-Object {
                    if ($_.PSIsContainer) {
                        Write-Host "üìÅ $($_.Name)/" -ForegroundColor Blue
                    } else {
                        Write-Host "üìÑ $($_.Name)" -ForegroundColor White
                    }
                }
            } else {
                Write-Host "‚ùå Workspace path not found: $workspacePath" -ForegroundColor Red
            }
            Write-Host ""
        }
        
        # Check for important files and directories related to WiX builds
        Write-Host "BUILD RESOURCES CHECK" -ForegroundColor Magenta
        Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
        
        # Check for WiX artifacts in source
        $buildDir = "$sourceDir/build"
        $altBuildDir = "$sourceDir/src/Azure.Functions.ArtifactAssembler/build"
        
        if (Test-Path $buildDir) {
            Write-Host "Using build directory: $buildDir" -ForegroundColor Green
            $wxsPath = "$buildDir/funcinstall.wxs"
        } elseif (Test-Path $altBuildDir) {
            Write-Host "Using alternative build directory: $altBuildDir" -ForegroundColor Yellow
            $buildDir = $altBuildDir
            $wxsPath = "$buildDir/funcinstall.wxs"
        } else {
            Write-Host "‚ùå Build directory not found!" -ForegroundColor Red
            # Try to find it
            Write-Host "Searching for build directory..." -ForegroundColor Yellow
            $possibleBuildDirs = Get-ChildItem -Path $sourceDir -Recurse -Directory -Filter "build" -ErrorAction SilentlyContinue | 
                Where-Object { Test-Path (Join-Path $_.FullName "funcinstall.wxs") }
                
            if ($possibleBuildDirs) {
                $buildDir = $possibleBuildDirs[0].FullName
                $wxsPath = "$buildDir/funcinstall.wxs"
                Write-Host "Found potential build directory: $buildDir" -ForegroundColor Green
            } else {
                $wxsPath = "Not found"
            }
        }
        
        # Check for specific WiX resources
        Check-FileExists -FilePath $wxsPath -Description "WiX installer definition (funcinstall.wxs)"
        Check-FileExists -FilePath "$buildDir/icon.ico" -Description "Installer icon"
        Check-FileExists -FilePath "$buildDir/license.rtf" -Description "License file"
        Check-FileExists -FilePath "$buildDir/installbanner.bmp" -Description "Installer banner"
        Check-FileExists -FilePath "$buildDir/installdialog.bmp" -Description "Installer dialog"
        
        # Check WiX environment
        Write-Host ""
        Write-Host "WIX TOOLSET CHECK" -ForegroundColor Magenta
        Write-Host "----------------------------------------------------------------" -ForegroundColor Blue
        
        if ($env:WIX) {
            Write-Host "WIX environment variable: $env:WIX" -ForegroundColor Green
            if (Test-Path "$env:WIX\bin\candle.exe") {
                Write-Host "‚úì Candle.exe found: $env:WIX\bin\candle.exe" -ForegroundColor Green
            } else {
                Write-Host "‚ùå Candle.exe not found at: $env:WIX\bin\candle.exe" -ForegroundColor Red
            }
            
            if (Test-Path "$env:WIX\bin\light.exe") {
                Write-Host "‚úì Light.exe found: $env:WIX\bin\light.exe" -ForegroundColor Green
            } else {
                Write-Host "‚ùå Light.exe not found at: $env:WIX\bin\light.exe" -ForegroundColor Red
            }
            
            if (Test-Path "$env:WIX\bin\heat.exe") {
                Write-Host "‚úì Heat.exe found: $env:WIX\bin\heat.exe" -ForegroundColor Green
            } else {
                Write-Host "‚ùå Heat.exe not found at: $env:WIX\bin\heat.exe" -ForegroundColor Red
            }
        } else {
            Write-Host "‚ùå WIX environment variable not set" -ForegroundColor Red
            
            # Try to find WiX in standard locations
            $possibleWixPaths = @(
                "C:\Program Files (x86)\WiX Toolset v3.11",
                "C:\Program Files\WiX Toolset v3.11",
                "C:\Program Files (x86)\Windows Installer XML v3.11"
            )
            
            foreach ($wixPath in $possibleWixPaths) {
                if (Test-Path "$wixPath\bin\candle.exe") {
                    Write-Host "Found WiX at: $wixPath" -ForegroundColor Yellow
                    break
                }
            }
        }
        
        # End measurement
        $endTime = Get-Date
        $duration = ($endTime - $startTime).TotalSeconds
        
        # Calculate summary values
        if (Test-Path $stagingPath) {
            $totalDirs = (Get-ChildItem $stagingPath -Recurse -Directory -ErrorAction SilentlyContinue | Measure-Object).Count
            $totalFiles = (Get-ChildItem $stagingPath -Recurse -File -ErrorAction SilentlyContinue | Measure-Object).Count
            $totalSize = (Get-ChildItem $stagingPath -Recurse -File -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
            $totalSizeFormatted = Format-FileSize $totalSize
            
            Write-Host ""
            Write-Host "=================================================================="
            Write-Host "SUMMARY" -ForegroundColor Green
            Write-Host "=================================================================="
            Write-Host "Total directories: $totalDirs" -ForegroundColor Blue
            Write-Host "Total files: $totalFiles" -ForegroundColor Blue
            Write-Host "Total size: $totalSizeFormatted" -ForegroundColor Yellow
            Write-Host "Analysis completed in $([math]::Round($duration, 2)) seconds"
            Write-Host "=================================================================="
        } else {
            Write-Host ""
            Write-Host "=================================================================="
            Write-Host "SUMMARY" -ForegroundColor Red
            Write-Host "=================================================================="
            Write-Host "‚ùå Staging directory not found - check previous steps"
            Write-Host "Analysis completed in $([math]::Round($duration, 2)) seconds"
            Write-Host "=================================================================="
        }

  - ${{ if eq(parameters.arch, 'min.win-x64') }}:
    - task: PowerShell@2
      displayName: 'Generate metadata.json file'
      inputs:
        targetType: filePath
        filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/generateMetadataFile.ps1'
        arguments: '-StagingDirectory "$(Pipeline.Workspace)\staging"'
        workingDirectory: '$(Pipeline.Workspace)'

  - ${{ if startsWith(parameters.arch, 'win') }}:
    - task: PowerShell@2
      displayName: 'Generate MSI files'
      inputs:
        targetType: filePath
        filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/generateMsiFiles.ps1'
        arguments: '-ArtifactsPath "$(Pipeline.Workspace)\staging\coretools-cli"'
        workingDirectory: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler'

  - ${{ if startsWith(parameters.arch, 'win-x') }}:
    - template: ci/sign-files.yml@eng
      parameters:
        displayName: Sign MSI files
        folderPath: $(Pipeline.Workspace)\staging\coretools-cli
        pattern: '*.msi'
        signType: 'inline'
        inlineOperation: |
          [
            {
              "KeyCode": "CP-230012",
              "OperationCode": "SigntoolSign",
              "Parameters": {
                "OpusName": "Microsoft",
                "OpusInfo": "http://www.microsoft.com",
                "FileDigest": "/fd \"SHA256\"",
                "PageHash": "/NPH",
                "TimeStamp": "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
              },
              "ToolName": "sign",
              "ToolVersion": "1.0"
            },
            {
              "KeyCode": "CP-230012",
              "OperationCode": "SigntoolVerify",
              "Parameters": {},
              "ToolName": "sign",
              "ToolVersion": "1.0"
            }
          ]

  - ${{ if eq(parameters.arch, 'min.win-x64') }}:
    - task: PowerShell@2
      displayName: 'Test Artifacts - Visual Studio'
      inputs:
        targetType: filePath
        filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/testVsArtifacts.ps1'
        arguments: '-StagingDirectory "$(Pipeline.Workspace)\staging\coretools-visualstudio"'
        workingDirectory: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler'

  - ${{ if startsWith(parameters.arch, 'win') }}:
    - task: PowerShell@2
      displayName: 'Test Artifacts'
      inputs:
        targetType: filePath
        filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/testArtifacts.ps1'
        arguments: '-StagingDirectory "$(Pipeline.Workspace)\staging\coretools-cli"'
        workingDirectory: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler'

  - task: DotNetCoreCLI@2
    displayName: 'Zip Artifacts'
    inputs:
      command: run
      projects: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/Azure.Functions.ArtifactAssembler.csproj'
      arguments: '--no-build -c release -- zip'
      workingDirectory: '$(Pipeline.Workspace)'

  - task: PowerShell@2
    displayName: 'Generate SHA files'
    inputs:
      targetType: filePath
      filePath: '$(Build.SourcesDirectory)/src/Azure.Functions.ArtifactAssembler/PipelineHelpers/generateSha.ps1'
      arguments: '-CurrentDirectory "$(Pipeline.Workspace)"'

  - task: CopyFiles@2
    displayName: 'Copy Files to Artifact Staging Directory'
    inputs:
      SourceFolder: '$(Pipeline.Workspace)/staging'
      Contents: 'coretools-*/**'
      TargetFolder: '$(Build.ArtifactStagingDirectory)/core-tools'

  - ${{ if eq(parameters.arch, 'min.win-x64') }}:
    - task: CopyFiles@2
      displayName: 'Copy metadata.json to Artifact Staging Directory'
      inputs:
        SourceFolder: '$(Pipeline.Workspace)/staging'
        Contents: 'metadata.json'
        TargetFolder: '$(Build.ArtifactStagingDirectory)'